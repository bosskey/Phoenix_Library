module("projectiles",package.seeall)local Type = {}local Projectiles = {}local PooledTypes = {}local PooledClasses = {}function BaseClass() return Type["base"] end--START PHASED OUT CODElocal NWOBJ = {} NWOBJ.__index = NWOBJfunction NWOBJ:SetVectorA(vec) self.Data:SetOrigin(vec) endfunction NWOBJ:SetVectorB(vec) self.Data:SetStart(vec) endfunction NWOBJ:SetVectorNormal(vec) self.Data:SetNormal(vec) endfunction NWOBJ:SetAngle(ang) self.Data:SetAngle(ang) endfunction NWOBJ:SetFloatA(num) self.Data:SetMagnitude(num) endfunction NWOBJ:SetFloatB(num) self.Data:SetRadius(num) endfunction NWOBJ:SetEntityA(ent) self.Data:SetEntity(ent) endfunction NWOBJ:SetEntityB(ent) self.Data:SetSurfaceProp(ent) endlocal function CreateNWOBJ(effectData)	local objNew = {}	setmetatable(objNew,NWOBJ)	objNew.Data = effectData	return objNewend--END PHASED OUT CODElocal function PoolType(strType)	if not PooledTypes[strType] then		PooledTypes[strType] = table.Count(PooledTypes) + 1	endendlocal function GetPooledType(strType) return PooledTypes[strType] endlocal function GetPooledClass(strType,strClass)	if not PooledClasses[strType] then return {} end	local tbl = PooledClasses[strType][strClass]	if tbl then		return tbl.id	end	return {}endlocal function GetClassData(strType,strClass)	if not PooledClasses[strType] then return {} end	local tbl = PooledClasses[strType][strClass]	if tbl then		return tbl.data	end	return {}endfunction _Register(strName, tblMeta)	if not Type[strName] then		PoolType(strName)		Type[strName] = tblMeta	endendfunction RegisterClass(strType,strClass,tblClassData)	if not PooledClasses[strType] then PooledClasses[strType] = {} end	if not PooledClasses[strType][strClass] then		PooledClasses[strType][strClass] = {id=table.Count(PooledClasses[strType]) + 1,data=tblClassData}	endendlocal function Create(strType,tblClassData)	if Type[strType] then		local objNew = {}		setmetatable(objNew,Type[strType])		table.Merge(objNew.Config,tblClassData or {})		return objNew	endendumsg.PoolString("PhoenixProjectile")function Shoot(strType,strClass,tblSetup)	local objProj = Create(strType,GetClassData(strType,strClass))	objProj.Entity = objProj	--objProj:Setup(objNW,tblSetup) --Setup NW Data (obj handles it)	--util.Effect("projectiles_core",effectData,true) --All are effects, we use them to input think, render, init, to our clientside projectile object counterpart	local rf = RecipientFilter()	rf:AddAllPlayers()	if GetConVarString("phxlib_prediction") == "1" then		rf:RemovePlayer(tblSetup.Shooter)	end	umsg.Start("PhoenixProjectile",rf)		umsg.Short(GetPooledType(strType))		umsg.Short(GetPooledClass(strType,strClass))		objProj:Setup(tblSetup)	umsg.End()	local func = objProj.Initialize --Run initialize hook on entity	if type(func) == "function" then		local bOk, valReturn = pcall(func,objProj)		if not bOk then			LibErrorHalt(valReturn)		end	else		LibErrorHalt("attempt to call non-function")	end	objProj.Index = table.insert(Projectiles,objProj)endfunction GetByIndex(numIndex)	if type(numIndex) == "number" and numIndex > 0 then		return Projectiles[numIndex] or NULL	end	return NULLendhook.Add("Think",NAME,function ()	--local ToRemove = {}	for k, obj in pairs(Projectiles) do		local func = obj.Think		if type(func) == "function" then			local bOk, valReturn = pcall(func,obj)			if bOk then				if not valReturn then					Projectiles[k] = nil				end			else				LibErrorHalt(valReturn)			end		end	end	--if #ToRemove then		--for k, v in pairs(ToRemove) do			--table.remove(Projectiles,v)		--end	--endend)