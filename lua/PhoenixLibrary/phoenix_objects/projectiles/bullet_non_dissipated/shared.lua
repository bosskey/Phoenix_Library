--OBJ_NAME = "base_bullet"--THIS IS THE 'DEFAULT' CLASS for the objectOBJ.Config = {	AllowRicochet = true,	AllowWorldPenetration = true,	AllowPlayerPenetration = true,	AllowEntityPenetration = true,	MaxRicochet = 2, --Number of times to ricochet before calling it quits and just digging it into the wall.	RicochetAngleThreshold = 30, --MAX ANGLE OF INCIDENCE	MaxPenetrationDist = 50, --UNITS	AllowSlowmoDrawing = true,	--Existential = true, --Leave bullet models behind	BulletGibLiveTime = 60,	AirResistance = .02,	EnableHeatwave = true,	UnlimitedRicochet = false,	Tracer = "cable/redlaser",	FrameSkip = 0, --Skip think frames (skip this many) to save on processing	PenetrateDeflectRatio = .2}OBJ.RicochetCount = 0OBJ.PenetrateWorld = {	Active = false,	MaxDist = nil,	StartPos = Vector(0,0,0)}local DEBUG_ON = truelocal numVelScale, numGravity = 1, 515.2local cvar_timescale, cvar_gravity = GetConVar("phxlib_timescale"), GetConVar("sv_gravity")cvars.AddChangeCallback("sv_gravity",function (cvar, old, new) numGravity = (tonumber(cvar_gravity:GetString())/600)*515.2 end)function OBJ:CalcMovePos(tStart)	local fDelta = CurTime() - tStart	if fDelta <= 0 then if DEBUG_ON then ErrorNoHalt("BULLET: CalcMove Fdelta "..tostring(fDelta).."@"..tostring(CurTime()).."\n") end end	local newVel = self:GetVelocity()	if self.PenetrateWorld.Active then --You cant pull a bullet down through the walls...lol		--newVel = newVel - newVel:GetNormal()*fDelta*(self.PenetrateWorld.StartPos:Distance(self.Entity:GetPos())/self.PenetrateWorld.MaxDist) --TOO FUCKING LAGGY, PLEASE REDUCE E-PENIS SIZE	else		newVel = newVel - self:GetVelocity():GetNormal()*self.Config.AirResistance*tonumber(GetConVarString("phxlib_timescale",1))*fDelta		newVel.z = newVel.z - numGravity*tonumber(GetConVarString("phxlib_timescale","1"))*fDelta	end	self:SetVelocity(newVel)	return self.Entity:GetPos() + self:GetVelocity()*tonumber(GetConVarString("phxlib_timescale","1"))*fDelta, fDeltaend--Need to do penetration!_C.BULLET_HITWORLD = 1_C.BULLET_HITLIVING = 2_C.BULLET_HITPROP = 3_C.BULLET_HITSKY = 4_C.BULLET_HITNOTHING = 0_C.BULLET_PENETRATEWORLD = 5_C.BULLET_DIGIN = 6_C.BULLET_PENETRATEWORLD_EXIT = 7_C.BULLET_PENETRATEWORLD_ACTIVE = 8local MAXDIST_PENETRATE_MAT = { --Velocity at 1000 ft/s	[MAT_FOLIAGE] = 16*4,	[MAT_GLASS] = 16*.3,	[MAT_SLOSH] = 16*.05,	[MAT_DIRT] = 16*.5,	[MAT_PLASTIC] = 16*.2,	[MAT_SAND] = 16*.1,	[MAT_WOOD] = 16*.8,	[MAT_CONCRETE] = 16*1}local DO_RICOCHET_MAT = {	[MAT_CLIP] = true, --huh?	[MAT_CONCRETE] = true,	[MAT_GRATE] = true,	[MAT_METAL] = true,	[MAT_TILE] = true,	[MAT_VENT] = true}function OBJ:DoMove(vecNewPos,fDelta)	local vecNewDir	self.traceData.filter = {self.Shooter,unpack(self.Filter)} --Hella unoptimized	while true do --allow ricocheting multiple times in a single frame (high amount of frameskip or just some serious slowdowns would promote this crazy situation)		if self:GetVelocity():Length() < 1 then			if DEBUG_ON then ErrorNoHalt("BULLET: velocity too low@"..tostring(CurTime()).."\n") end			return true, self.Entity:GetPos(), BULLET_DIGIN, {}		end		if self.PenetrateWorld.Active then			--self.traceData.start = vecNewPos			--self.traceData.endpos = self.Entity:GetPos()			self.traceData.start = self.Entity:GetPos()			self.traceData.endpos = vecNewPos			self.traceData.mask = MASK_SHOT			local tr = util.TraceLine(self.traceData)			local trNewPos = util.TraceLine({start=vecNewPos,endpos=vecNewPos,mask=MASK_SHOT})			if self.PenetrateWorld.EntryPos:Distance(vecNewPos) > self.PenetrateWorld.MaxDist or tr.HitSky or (util.PointContents(vecNewPos) == CONTENTS_SOLID and not trNewPos.StartSolid) then				if DEBUG_ON then ErrorNoHalt("PENETRATE: dugin@"..tostring(CurTime()).."\n") end				self.PenetrateWorld.Active = false				return true, vecNewPos, BULLET_DIGIN, tr --DONE			elseif not trNewPos.StartSolid and tr.HitWorld then --make sure we didn't just fly out of the world like wtf				if DEBUG_ON then ErrorNoHalt("PENETRATE: exit@"..tostring(CurTime()).."\n") end				self.PenetrateWorld.Active = false				return false, vecNewPos, BULLET_PENETRATEWORLD_EXIT, tr -- DONE/CORRECT			else				return false, vecNewPos, BULLET_PENETRATWORLD_ACTIVE, tr --continue on			end		else			self.traceData.start = self.Entity:GetPos()			self.traceData.endpos = vecNewPos			self.traceData.mask = MASK_SHOT			local tr = util.TraceLine(self.traceData)			if tr.Hit then				if tr.HitSky then					if DEBUG_ON then ErrorNoHalt("BULLET: hitsky@"..tostring(CurTime()).."\n") end					return true, tr.HitPos, BULLET_HITSKY, tr				elseif tr.HitWorld then					local angIncidence = math.abs(tr.HitNormal:DotProduct(tr.Normal))*90 --FIXED :D					if tr.StartSolid then						if DEBUG_ON then ErrorNoHalt("BULLET: inworld@"..tostring(CurTime()).."\n") end						return true, tr.StartPos, BULLET_PENETRATE_DIGIN, tr					elseif self.Config.AllowRicochet and DO_RICOCHET_MAT[tr.MatType] and angIncidence <= self.Config.RicochetAngleThreshold and (self.UnlimitedRicochet or self.RicochetCount < self.Config.MaxRicochet) then						vecNewDir = tr.Normal - (2*tr.HitNormal*tr.HitNormal:DotProduct(tr.Normal))						vecNewPos = tr.HitPos + vecNewDir*(vecNewPos:Distance(tr.StartPos)*(1-tr.Fraction))						--vecNewPos = tr.HitPos + vecNewDir*((tr.HitPos - tr.StartPos):Length()/(vecNewPos - tr.StartPos):Length())*(vecNewPos - tr.StartPos):Length() --NOTE: double check this for accuracy...						self.Entity:SetPos(tr.HitPos)						self.Entity:SetAngles(vecNewDir:Angle())						--local vecRicScale = tr.HitNormal:DotProduct(self:GetVelocity())*self:GetVelocity() --Yeah, special velocity decay depending on direction, kinda like momentum decaying the full ricochet effect from happenening						self:SetVelocity(vecNewDir*self:GetVelocity():Length()) --*(.25 + (1 - angIncidence/self.Config.RicochetAngleThreshold)*.75))						self.RicochetCount = self.RicochetCount + 1						--Do another ricochet check...						if DEBUG_ON then ErrorNoHalt("BULLET: ricochet["..tostring(self.RicochetCount).."]@"..tostring(CurTime()).."\n") end					else						if DEBUG_ON then ErrorNoHalt("PENETRATE: start@"..tostring(CurTime()).."\n") end						local numMaxDist = (MAXDIST_PENETRATE_MAT[tr.MatType] or 1)*(self:GetVelocity():Length())*.001 --velocity/1000 for scale purposes, this is so geniusly simple... XD						--Fix new direction with dot products and ricochet core code remake...right now, this'll have to do						--vecNewDir = self:GetVelocity():GetNormal()						--vecNewDir = self:GetVelocity():Angle() - (tr.Normal:Angle()):Difference((tr.HitNormal*-1):Angle())*self.Config.PenetrateDeflectRatio						--self.Entity:SetAngles(vecNewDir:Angle())						--self:SetVelocity(vecNewDir*self:GetVelocity():Length())						--vecNewPos = tr.HitPos + self:GetVelocity():GetNormal()*((vecNewPos - tr.HitPos):Length()/(vecNewPos - tr.StartPos):Length())*(vecNewPos - tr.StartPos):Length() --NOTE: do this length in the new direction (length is the amount we already predict-penetrated), MAYBE ADD THE VELOCITY DECAY TOO BY THE LENGTH WE WENT IN / MAXDIST						self.Entity:SetPos(vecNewPos)						self.PenetrateWorld.Active = true						self.PenetrateWorld.StartPos = vecNewPos						self.PenetrateWorld.EntryPos = tr.HitPos						self.PenetrateWorld.StartVel = self:GetVelocity()						self.PenetrateWorld.MaxDist = numMaxDist						self:SetVelocity(self.PenetrateWorld.StartVel) --*(1 - self.PenetrateWorld.EntryPos:Distance(vecNewPos)/self.PenetrateWorld.MaxDist))						return false, vecNewPos, BULLET_PENETRATEWORLD, tr --DONT USE TRACELINE ON THIS ONE					end				elseif ValidEntity(tr.Entity) and not tr.Entity:IsWorld() then					if tr.Entity:IsPlayer() or tr.Entity:IsNPC() then						--self.Penetrate.Entity = tr.Entity						--self.Penetrate.StartPos = tr.HitPos						--self.Penetrate.Active = true						--return false, false, tr.HitPos						if DEBUG_ON then ErrorNoHalt("BULLET: hitliving@"..tostring(CurTime()).."\n") end						return true, tr.HitPos, BULLET_HITLIVING, tr					elseif tr.Entity:GetClass() == "prop_physics" then						if DEBUG_ON then ErrorNoHalt("BULLET: hitprop@"..tostring(CurTime()).."\n") end						return true, tr.HitPos, BULLET_HITPROP, tr					end					if DEBUG_ON then ErrorNoHalt("BULLET: hitother@"..tostring(CurTime()).."\n") end					return true, tr.HitPos, BULLET_HITPROP, tr				else					if DEBUG_ON then ErrorNoHalt("BULLET: Hit but no block to run code\n") end				end				--ErrorNoHalt("BULLET: WTF NOTHING HAPPENED?\n")				--return true, tr.HitPos, BULLET_DIGIN, tr			else				return false, vecNewPos, BULLET_HITNOTHING, tr			end		end	endend